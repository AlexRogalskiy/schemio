struct TreeNode {
    id: ''
    parent: null
    x: 0
    y: 0
    siblingIdx: 0
    level: 0
    fullWidth: 0
    children: List()

    attachTo(parentNode) {
        this.parent = parentNode
        this.siblingIdx = parentNode.children.size
        parentNode.children.add(this)
    }

    attachChildAtIndex(childNode, idx) {
        childNode.parent = this
        this.children.insert(idx, childNode)
        this.children.forEach((node, nodeIdx) => {
            node.siblingIdx = nodeIdx
        })
    }

    encodeTree() {
        encoded = this.id
        this.children.forEach((childNode) => {
            childEncoded = childNode.encodeTree()
            encoded += ',' + childEncoded
        })
        encoded + ',N'
    }

    reindex() {
        this.level = if (this.parent) { this.parent.level + 1 } else { 0 }
        if (this.children.size > 0) {
            fullWidth = 0
            this.children.forEach((childNode) => {
                childNode.reindex()
                fullWidth += childNode.fullWidth
            })
            this.fullWidth = fullWidth + (this.children.size - 1) * hGap
        } else {
            this.fullWidth = width
        }
    }
}

decodeTree = (encodedText) => {
    nodeList = splitString(encodedText, ',')
    rootNode = TreeNode(nodeList.shift())
    currentNode = rootNode
    while(nodeList.size > 0) {
        nodeId = nodeList.shift()
        if (nodeId == 'N') {
            parent = currentNode.parent
            if (!parent) {
                parent = rootNode
            }
            currentNode = parent
        } else {
            newNode = TreeNode(nodeId)
            newNode.attachTo(currentNode)
            currentNode = newNode
        }
    }
    rootNode.reindex()
    rootNode
}
